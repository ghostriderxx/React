import assert from 'assert';
import chalk from 'chalk';
import fs from 'fs-extra';
import _ from 'lodash';
import path from 'path';
import rimraf from 'rimraf';

export function normalizeNode(node, debugName) {
    const tag = node.tagName;
    if (!tag) {
        throw new TypeError(`${debugName} Element should have no no-tag node`);
    }
    const attrs = node.attrs.reduce((acc, { name, value }) => {
        Object.defineProperty(acc, name, { value, enumerable: true });
        return acc;
    }, {});
    const children = node.childNodes.map((child) => normalizeNode(child, debugName));
    const result = {
        tag,
        attrs
    };
    if (children.length) {
        result.children = children;
    }
    return result;
}

/**
 * Parse the node generated by parse5 into the abstract tree.
 * @param node the node that need parsing.
 * @param debugName debug name, used in assert statement.
 */
export function generateAbstractTree(node, debugName) {
    assert(node, debugName);
    assert(node.tagName === 'svg', debugName);
    const viewBox = node.attrs.find(({ name }) => name === 'viewBox');
    assert(viewBox, debugName);
    const size = viewBox.value
        .split(' ')
        .slice(2)
        .map((str) => Number.parseInt(str, 10));
    assert(
        size.length === 2,
        `The size tuple should be [ width, height ], but got [ ${size[0]}, ${size[1]} ] [${debugName}]`
    );
    const oneLevelPathNodes = node.childNodes.filter(
        ({ nodeName, childNodes }) => nodeName !== 'style' && childNodes.length === 0
    );
    assert(oneLevelPathNodes.length >= 1, debugName);

    return normalizeNode(node, debugName);
}

export const log = {
    info(message) {
        return console.log(chalk.green(`ðŸŒŸ [Generate] ${message}`));
    },
    notice(message) {
        return console.log(chalk.blueBright(`ðŸŒŸ [Notice] ${message}`));
    }
};

export function getIdentifier(identifier, theme) {
    switch (theme) {
        case 'fill':
            return `${identifier}Fill`;
        case 'outline':
            return `${identifier}Outline`;
        case 'twotone':
            return `${identifier}TwoTone`;
        default:
            throw new TypeError(`Unknown theme type: ${theme}, identifier: ${identifier}`);
    }
}

/**
 * Clear by using 'rimraf'.
 */
export async function clear(env) {
    log.notice(`Clear folders.`);
    return Promise.all(
        Object.keys(env.paths)
            .filter((key) => key.endsWith('OUTPUT')) // DO NOT DELETE THIS LINE!!!
            .map((key) => {
                // This is evil. Make sure you just delete the OUTPUT.
                log.notice(`Delete ${path.relative(env.base, env.paths[key])}.`);
                return new Promise((resolve) => rimraf(env.paths[key], resolve));
            })
    );
}

export function isAccessable(url) {
    let accessable = false;
    try {
        fs.accessSync(url);
        accessable = true;
    } catch (error) {
        accessable = false;
    }
    return accessable;
}

export function replaceFillColor(raw) {
    return raw
        .replace(/['"]#333['"]/g, 'primaryColor')
        .replace(/['"]#E6E6E6['"]/g, 'secondaryColor')
        .replace(/['"]#D9D9D9['"]/g, 'secondaryColor')
        .replace(/['"]#D8D8D8['"]/g, 'secondaryColor');
}
